{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BlockFactory \u00b6 BlockFactory is a framework for dataflow programming that allows wrapping C and C++ algorithms . It provides an abstraction inspired by Simulink where algorithms are represented as blocks that can exchange data through signals . Users of this project can easily wrap their algorithms inside the provided software interfaces obtaining C++ classes that can be executed by generic engines . BlockFactory implements and provides full support of the following engines: Simulink Simulink Coder The main purpose of BlockFactory is rapid prototyping of discrete systems (stateless and stateful). Taking as an example the supported Simulink engine, it simplifies and streamlines the process of creating a block. You don't have be an expert of its complex APIs! Furthermore, with Simulink Coder you can generate C++ code from a Simulink model. You can then deploy the automatically generated C++ class from an arbitrarily complex model to your preferred target platform. The same code of the blocks is shared among all the supported engines. This means that the same shared library containing your blocks can either be loaded into Simulink during runtime or called by the executable built from the automatically generated code, without any modification. If you need to run your code inside an unsupported engine (e.g. Scilab), you can implement it yourself with minimal effort. How we conceived BlockFactory \u00b6 BlockFactory for many years represented the back-end of robotology/wb-toolbox , a Simulink Toolbox for rapid prototyping of humanoid robots whole-body controllers. The toolbox was recently refactored and its core components became BlockFactory. Despite its roots in robotics, now BlockFactory is very generic! You can use it to wrap your own C / C++ libraries to simulate power converters, design communication systems, benchmark motor drives, interface with exotic devices, and all applications that come in your mind. Its potential is endless. Build bridges, not walls","title":"Home"},{"location":"#blockfactory","text":"BlockFactory is a framework for dataflow programming that allows wrapping C and C++ algorithms . It provides an abstraction inspired by Simulink where algorithms are represented as blocks that can exchange data through signals . Users of this project can easily wrap their algorithms inside the provided software interfaces obtaining C++ classes that can be executed by generic engines . BlockFactory implements and provides full support of the following engines: Simulink Simulink Coder The main purpose of BlockFactory is rapid prototyping of discrete systems (stateless and stateful). Taking as an example the supported Simulink engine, it simplifies and streamlines the process of creating a block. You don't have be an expert of its complex APIs! Furthermore, with Simulink Coder you can generate C++ code from a Simulink model. You can then deploy the automatically generated C++ class from an arbitrarily complex model to your preferred target platform. The same code of the blocks is shared among all the supported engines. This means that the same shared library containing your blocks can either be loaded into Simulink during runtime or called by the executable built from the automatically generated code, without any modification. If you need to run your code inside an unsupported engine (e.g. Scilab), you can implement it yourself with minimal effort.","title":"BlockFactory"},{"location":"#how-we-conceived-blockfactory","text":"BlockFactory for many years represented the back-end of robotology/wb-toolbox , a Simulink Toolbox for rapid prototyping of humanoid robots whole-body controllers. The toolbox was recently refactored and its core components became BlockFactory. Despite its roots in robotics, now BlockFactory is very generic! You can use it to wrap your own C / C++ libraries to simulate power converters, design communication systems, benchmark motor drives, interface with exotic devices, and all applications that come in your mind. Its potential is endless. Build bridges, not walls","title":"How we conceived BlockFactory"},{"location":"about/","text":"BlockFactory has been developed in the Dynamic Interaction Control research line at the Italian Institute of Technology . It used to be the core machinery of robotology/wb-toolbox . Now it became a standalone and generic tool, not anymore related to robotic applications. Maintainer \u00b6 Ferigo Diego ( @diegoferigo ) Contributors \u00b6 In alphabetical order: Eljaik Jorhabib ( @jeljaik ) Ferigo Diego ( @diegoferigo ) Nori Francesco ( @iron76 ) Pucci Daniele ( @DanielePucci ) Romano Francesco ( @francesco-romano ) Traversaro Silvio ( @traversaro ) Acknowledgments \u00b6 The development of BlockFactory is supported by: FP7 EU projects CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics) H2020 EU projects AnDy (No. 731540 H2020-ICT-2016-1)","title":"About"},{"location":"about/#maintainer","text":"Ferigo Diego ( @diegoferigo )","title":"Maintainer"},{"location":"about/#contributors","text":"In alphabetical order: Eljaik Jorhabib ( @jeljaik ) Ferigo Diego ( @diegoferigo ) Nori Francesco ( @iron76 ) Pucci Daniele ( @DanielePucci ) Romano Francesco ( @francesco-romano ) Traversaro Silvio ( @traversaro )","title":"Contributors"},{"location":"about/#acknowledgments","text":"The development of BlockFactory is supported by: FP7 EU projects CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics) H2020 EU projects AnDy (No. 731540 H2020-ICT-2016-1)","title":"Acknowledgments"},{"location":"autogenerate_code/","text":"How to autogenerate C++ code \u00b6 Warning This tutorial is not yet ready The capability of autogenerating C++ code from a Simulink model is provided by Simulink Coder. BlockFactory received a preliminary support of this toolbox, and only basic features are currently supported. Following the previous how-to, check these links for a simple example: AutogenerationExample.mdl A Simulink model with the right configuration of Simulink Coder example/matlab/AutogenerationExample_grt_rtw The folder containing the autogenerated sources 'example/matlab/CMakeLists.txt' The CMake file for compiling the generated code src/main.cpp A simple main function to execute the autogenerated code","title":"Autogenerate C++ code"},{"location":"autogenerate_code/#how-to-autogenerate-c-code","text":"Warning This tutorial is not yet ready The capability of autogenerating C++ code from a Simulink model is provided by Simulink Coder. BlockFactory received a preliminary support of this toolbox, and only basic features are currently supported. Following the previous how-to, check these links for a simple example: AutogenerationExample.mdl A Simulink model with the right configuration of Simulink Coder example/matlab/AutogenerationExample_grt_rtw The folder containing the autogenerated sources 'example/matlab/CMakeLists.txt' The CMake file for compiling the generated code src/main.cpp A simple main function to execute the autogenerated code","title":"How to autogenerate C++ code"},{"location":"create_new_library/","text":"How to create a new library \u00b6 This guide describes how to use BlockFactory for creating a new toolbox Toolbox Example . It will contain a single block Signal math with the following specifications: Accepts two input signals Performs element-wise operations: sum, subtraction, multiplication Allows to select the operation with a user friendly GUI (mask) Produces an output signal with the result of the operation Despite it is a very trivial example, it shows how to structure both the C++ and the Matlab components of a toolbox. From this starting point is then possible to build more complex architectures which might need e.g. to be split in many parts or to link against third-party libraries. Toolbox Example project You can find the files of this example in the example folder. Introduction \u00b6 Before jumping in the example of this tutorial, in this section you will find helpful information useful to grasp the key ideas about the toolbox and a refreshing of common terms and patterns used in programming. Algorithm specifications \u00b6 The execution of a generic algorithm can be split in the following basic phases: Configuration Initialization Step Termination In the configuration phase the algorithm can, for instance, read parameters and specify details about its inputs and outputs. During the initialization it might need to allocate resources. When everything is ready, the simulation starts and on every cycle of the loop the algorithm computes a step. Before finishing the simulation, in the termination step the resources that are not anymore needed can be deallocated and final operations can be executed. Terminology \u00b6 There are few key components which are part of the core infrastructure, and it is important they are clear from the very beginning. Note This project has strong roots with Simulink. Despite it is not anymore strictly related to it, the structure keeps as inheritance its terminology. Block \u00b6 The Block is the main component of the toolbox. You may think of it as a wrapper for a generic algorithm. It provides support of all the phases discussed above. Port \u00b6 Blocks need to interface with the outside for reading input data and writing their results. Ports are attached to the Block and let data flow in and out from it. They have properties like the accepted data type and they are characterized by a size. Signal \u00b6 A Signal is the generalization of a buffer. It can be plugged to multiple Ports and allows sharing data between them. Similarly to Ports, a Signal has a data type and a width. When a Signal is connected to a Port, their dimension must match. Engine \u00b6 The engine is the framework that calls and executes the code implementing the Blocks. We currently provide support for Simulink and Simulink Coder. Alternative engines might be Scilab or even standalone C++ code. BlockInformation \u00b6 BlockInformation is the interface between a Block and the engine that executes its code. Despite blocks are not aware of what engine is executing them, blocks and engine need to exchange information such as user parameters and Port data. BlockInformation provides methods for setting and getting this piece of information. Simulink Block \u00b6 A Simulink Block is the wrapper of a (C++) Block. It provides a visual representation of it, with input and output ports and gives the possibility to connect it with other Simulink blocks through signals. The terms above come from this representation and map it to C++. Simulink Model \u00b6 A Simulink Model is a project composed of a set of Simulink Blocks interconnected by Signals. Simulink Library \u00b6 A Simulink Library is a container of a set of Blocks that populates the Simulink Library Browser . Every toolbox must be shipped with an associated Simulink Library file in order to expose its Blocks. S-Function \u00b6 There are many types of functions for implementing an algorithm wrapped by a Simulink Block. In Matlab terminology, these functions are referred as S-Functions . You can read more about the supported types in What type of S-Function should you use . In short S-Functions provide a sort of interface (through C callbacks) where a given number of functions need to be implemented. Simulink knows the name of these functions and calls them on demand. Block Mask \u00b6 A Simulink Block is just a square with input and output ports. It is possible to \"mask\" a Simulink Block in order to provide a user-friendly GUI that can be useful e.g. for setting Block parameters. The mask may contain buttons, sliders, check boxes, dropdown menus, etc. Software library \u00b6 A library is a file containing compiled code (functions, classes, constants, etc.) which cannot be executed standalone. It can be either static or dynamic . Static libraries are meant to be embedded inside the executable that calls their symbols, instead the code of dynamic libraries (also called shared libraries) is only referenced inside the executable and called when needed. To grasp better this difference, if multiple executables link against the same static library, the same code is embedded inside all of them, resulting in bigger executables and code duplication. A dynamic library object instead can be shared by multiple executables that need only to know its location in the filesystem and which symbols it provide. Info You can find more detailed information about software libraries and linkers at this link . Plugin Library \u00b6 A plugin library is a particular type of a dynamic library. An executable can load dynamic libraries either at load time, i.e. when the executable is launched, or at run time, i.e. when needed during the execution. The libraries that can be loaded during run time are referred as plugins. Info On UNIX systems the load of a plugin is executed by a dlopen call Overview of Simulink execution \u00b6 BlockFactory provides a framework capable of loading during runtime shared libraries (plugins). When the Simulink simulation starts, its engine assigns a deterministic order to the blocks of the Simulink Model. If one of these blocks is not contained in the default toolboxes provided by Mathworks, it needs to be associated to a S-Function that implements its logic. The toolbox provides a streamlined approach to implement these functions without the need of being an expert of the complex Simulink APIs. The blocks of our library are implemented in Simulink using the following S-Function block: For the time being, what you need to know is that the name of the plugin library generated from the C++ code will be stored in the S-function parameters field of the block mask. We provide a generic Level-2 MEX S-Function that reads this parameter and uses the library name name to dynamically load the dynamic library that contains the block's code. After the library is found in the filesystem and successfully loaded, Simulink allocates an object of the C++ class associated to the block functionality. Again, this information (the class name) is passed in the S-function parameters field of the block mask. Develop the C++ plugin \u00b6 You already learned that Blocks are no more than regular C++ classes. They are not an exception, in fact all the components discussed until now are mapped to C++ classes or interfaces ( abstract classes ). The following resources provide further information about them: Blocks are implementations of the blockfactory::core::Block interface BlockInformation is defined in the blockfactory::core::BlockInformation interface Signals are mapped to the blockfactory::core::Signal class Blocks parameters are mapped to the blockfactory::core::Parameter class We need the following folder structure for the C++ project. Create already the empty files so the project can compile from the very first attempt. . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp Info All the path of this tutorial will be relative to the root folder of the project. This means that if the directory tree above is stored in /home/foo/tutorial , when you read to go the ./build directory it means /home/foo/tutorial/build . Tip Bear in mind that this C++ class is independent from Simulink. Potentially, it can be called by a standalone C++ executable. Tip It is not mandatory to implement a new class for every Simulink Block. If they share a lot of code, a single class can be referenced by multiple Simulink Blocks and its behavior can be selected using parameters. Tip You can use all the external libraries you want to implement the code of this class. CMake project for compiling the library \u00b6 You are free to use your favourite tool for compiling the project. We recommend CMake. If you are not an expert user of this tool, just follow the steps. The comments in the file should be enough to understand what it is happening. Fill the file CMakeLists.txt with the following content: cmake_minimum_required ( VERSION 3.5 ) project ( ExampleToolbox LANGUAGES CXX VERSION 0.1 ) # C++ standard set ( CMAKE_CXX_STANDARD 14 ) set ( CMAKE_CXX_STANDARD_REQUIRED ON ) # Export all symbols in Windows set ( CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON ) # Utility for defining install folders include ( GNUInstallDirs ) # Tweak linker flags in Linux. # Matlab is very strict on missing symbols and by default ld do not warn if # something is missing. if ( UNIX AND NOT APPLE ) get_filename_component ( LINKER_BIN ${ CMAKE_LINKER } NAME ) if ( ${ LINKER_BIN } STREQUAL \"ld\" ) set ( CMAKE_SHARED_LINKER_FLAGS \"-Wl,--unresolved-symbols=report-all\" ) endif () endif () # =========== # C++ LIBRARY # =========== # Find the needed BlockFactory components: # - \"Core\" contains the core classes such as Block and Signal # - \"Simulink\" is required at runtime for loading the library from Simulink find_package ( BlockFactory REQUIRED COMPONENTS Core OPTIONAL_COMPONENTS Simulink ) # Create the plugin library. This must be a SHARED library. add_library ( ExampleToolbox SHARED include/SignalMath.h src/SignalMath.cpp src/Factory.cpp ) # Manually set the name of the output library. This is not required and it # is done only for sake of clarity. set_target_properties ( ExampleToolbox PROPERTIES OUTPUT_NAME \"ExampleToolbox\" ) # Link the library with the Core component containing the core classes target_link_libraries ( ExampleToolbox PRIVATE BlockFactory::Core ) # Setup the include directories target_include_directories ( ExampleToolbox PRIVATE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > ) Note If your library needs to link against other libraries, use find_package to load their targets and then add them to the target_link_libraries directive. Compiling instructions From the root folder of the project, execute: GNU/Linux and macOS mkdir build cd build cmake .. cmake --build . Windows mkdir build cd build cmake .. cmake --build . --config Release You should now find in the ./build directories a new library file, which depending on your OS is: libExampleToolbox.so on Linux libExampleToolbox.dylib on macOS ExampleToolbox.dll on Windows This is the toolbox's plugin library which is loaded during runtime by the active Engine. Implement the block logic \u00b6 The only Signal math block of our new toolbox will be implemented in a example::SignalMath C++ class. Header \u00b6 Here below the ./include/SignalMath.h header. Given the simple logic it should be straightforward to understand. The class inherits from the blockfactory::core::Block interface and implements some of its methods. Info The only mandatory method to implement is the blockfactory::core::Block::output . By default the other methods are dummy and they always return true . #ifndef EXAMPLE_SIGNALMATH_H #define EXAMPLE_SIGNALMATH_H #include <BlockFactory/Core/Block.h> #include <BlockFactory/Core/BlockInformation.h> #include <memory> #include <string> namespace example { class SignalMath ; } // namespace example class example :: SignalMath : public blockfactory :: core :: Block { private : enum class Operation { ADDITION , SUBTRACTION , MULTIPLICATION , }; Operation m_operation ; public : static const std :: string ClassName ; SignalMath () = default ; ~ SignalMath () override = default ; unsigned numberOfParameters () override ; bool parseParameters ( blockfactory :: core :: BlockInformation * blockInfo ) override ; bool configureSizeAndPorts ( blockfactory :: core :: BlockInformation * blockInfo ) override ; bool initialize ( blockfactory :: core :: BlockInformation * blockInfo ) override ; bool output ( const blockfactory :: core :: BlockInformation * blockInfo ) override ; bool terminate ( const blockfactory :: core :: BlockInformation * blockInfo ) override ; }; #endif // EXAMPLE_SIGNALMATH_H The ./src/SignalMath.cpp file is more interesting, let's split it in chunks. Parameters \u00b6 If you recall, BlockInformation is used by the Block for interfacing with the Engine. When this code is executed inside Simulink, the blockfactory::core::SimulinkBlockInformation implementation will perform the required operations calling Simulink APIs. #include \"SignalMath.h\" #include <BlockFactory/Core/Log.h> #include <BlockFactory/Core/Parameter.h> #include <BlockFactory/Core/Signal.h> using namespace example ; unsigned SignalMath :: numberOfParameters () { // The base blockfactory::core::Block class needs parameters (e.g. the ClassName). // You must specify here how many more parameters this class needs. // Our example needs just one more: the operation to perform. return Block :: numberOfParameters () + 1 ; } // This method should let BlockInformation know the parameters metadata. // BlockFactory will use this information to gather the parameters from the active engine. bool SignalMath :: parseParameters ( blockfactory :: core :: BlockInformation * blockInfo ) { // Initialize information for our only parameter int rows = 1 ; int cols = 1 ; std :: string name = \"Operation\" ; // This label is used later to access the paramemeter unsigned index = Block :: numberOfParameters (); // Indices start from 0 auto type = blockfactory :: core :: ParameterType :: STRING ; // Create the parameter blockfactory :: core :: ParameterMetadata parameterMetadata ( type , index , rows , cols , name ); // Add the parameter metadata into the BlockInformation if ( ! blockInfo -> addParameterMetadata ( parameterMetadata )) { bfError << \"Failed to store parameter metadata\" ; return false ; } // Ask to the BlockInformation interface to parse the parameters and store them into // the protected m_parameters member of the parent blockfactory::core::Block class. bool paramParsedOk = blockInfo -> parseParameters ( m_parameters ); // Return the outcome of the parameter parsing. // If the parsing fails, the execution stops. return paramParsedOk ; } Configuration \u00b6 The configuration of the Block is performed in the following steps: The base class needs to be configured. It needs some parameters (e.g. the class name and the library name) and this call asks the Engine to parse them. The ports of the Block need to be defined. In this example the size is set as dynamic so that it accepts signals with any width. The data is then sent to the Engine through the BlockInformation interface. Info If needed, parameters can be accessed from this step. Refer to the initialization phase to understand how to gather them. Signal size Simulink has the support of inheriting the port size from the signal size, though use this feature only when strictly needed. In complex Simulink Models the Engine might have difficulties to execute this size propagation, and fixing the Port sizes provides helpful constraints (especially for blocks with only outputs) Important Be careful on memory allocations during this step. A temporary object is created only for configuration means, and then destroyed. All the allocated memory will be hereby deleted. bool SignalMath :: configureSizeAndPorts ( blockfactory :: core :: BlockInformation * blockInfo ) { // The base blockfactory::core::Block class needs to be configured first if ( ! blockfactory :: core :: Block :: configureSizeAndPorts ( blockInfo )) { return false ; } // Create object that store input and output ports information blockfactory :: core :: Port :: Info input1 { /*portIndex=*/ 0 , std :: vector < int > { blockfactory :: core :: Port :: DynamicSize }, blockfactory :: core :: Port :: DataType :: DOUBLE }; blockfactory :: core :: Port :: Info input2 { /*portIndex=*/ 1 , std :: vector < int > { blockfactory :: core :: Port :: DynamicSize }, blockfactory :: core :: Port :: DataType :: DOUBLE }; blockfactory :: core :: Port :: Info output { /*portIndex=*/ 0 , std :: vector < int > { blockfactory :: core :: Port :: DynamicSize }, blockfactory :: core :: Port :: DataType :: DOUBLE }; // Store together the port information objects blockfactory :: core :: InputPortsInfo inputPortInfo ; blockfactory :: core :: OutputPortsInfo outputPortInfo ; inputPortInfo . push_back ( input1 ); inputPortInfo . push_back ( input2 ); outputPortInfo . push_back ( output ); // Store the port information into the BlockInformation if ( ! blockInfo -> setPortsInfo ( inputPortInfo , outputPortInfo )) { bfError << \"Failed to configure input / output ports\" ; return false ; } return true ; } Initialization \u00b6 Info Starting from this step, memory persistence is guaranteed. In the initialisation step, the input parameter that defines the operation is parsed. In this example the parameter is passed as a string. In the header a new enum class Operation was defined and here the related private member is properly initialised. Additional checks can be added, i.e. testing that both ports have the same width given that a dynamic size was previously assigned. Info In this case there's no need to allocate memory. If your class has buffers to initialise, this is the right time to do it. bool SignalMath :: initialize ( blockfactory :: core :: BlockInformation * blockInfo ) { // The base blockfactory::core::Block class need to be initialized first if ( ! Block :: initialize ( blockInfo )) { return false ; } // Parse the parameters if ( ! SignalMath :: parseParameters ( blockInfo )) { bfError << \"Failed to parse parameters.\" ; return false ; } // Read the Operation parameter and store it as a private member std :: string operation ; if ( ! m_parameters . getParameter ( \"Operation\" , operation )) { bfError << \"Failed to parse Operation parameter\" ; return false ; } // Check the content of the parameter if ( operation == \"Addition\" ) { m_operation = Operation :: ADDITION ; } else if ( operation == \"Subtraction\" ) { m_operation = Operation :: SUBTRACTION ; } else if ( operation == \"Multiplication\" ) { m_operation = Operation :: MULTIPLICATION ; ; } else { bfError << \"Operation \" << operation << \" not recognized\" ; return false ; } // Check that the size of the input signals match if ( blockInfo -> getInputPortWidth ( /*index=*/ 0 ) != blockInfo -> getInputPortWidth ( /*index=*/ 1 )) { bfError << \"Input signals widths do not match\" ; return false ; } return true ; } Output \u00b6 The output method is where the real algorithm is implemented. The Signals are firstly gathered from the Engine using their index. The classes blockfactory::core::InputSignalPtr and blockfactory::core::OutputSignalPtr are particular typedef of the blockfactory::core::Signal class and they have the same methods. In the for loop the configured operation is performed and the result stored in the output signal. Note Note that input signals are read-only and accessed in C++ as const object. You can store data only to the output signals objects. bool SignalMath :: output ( const blockfactory :: core :: BlockInformation * blockInfo ) { // Get the input signals blockfactory :: core :: InputSignalPtr input1 = blockInfo -> getInputPortSignal ( /*index=*/ 0 ); blockfactory :: core :: InputSignalPtr input2 = blockInfo -> getInputPortSignal ( /*index=*/ 1 ); // Get the output signal blockfactory :: core :: OutputSignalPtr output = blockInfo -> getOutputPortSignal ( /*index=*/ 0 ); // Check the signal validity if ( ! input1 || ! input2 || ! output ) { bfError << \"Signals not valid\" ; return false ; } // Check the width of the output signal. // This check is recommended for dynamically sized signals since the engine might // fail to propagate the right dimensions. if ( output -> getWidth () != input1 -> getWidth ()) { bfError << \"Output signal has a width of \" << output -> getWidth () << \" while input signals have a width of \" << input1 -> getWidth (); return false ; } // Perform the given operation for ( size_t i = 0 ; i < output -> getWidth (); ++ i ) { switch ( m_operation ) { case Operation :: ADDITION : output -> set ( i , input1 -> get < double > ( i ) + input2 -> get < double > ( i )); break ; case Operation :: SUBTRACTION : output -> set ( i , input1 -> get < double > ( i ) - input2 -> get < double > ( i )); break ; case Operation :: MULTIPLICATION : output -> set ( i , input1 -> get < double > ( i ) * input2 -> get < double > ( i )); break ; } } return true ; } Terminate \u00b6 Given the simplicity of our Block, the terminate step is a dummy implementation. This method is reported just for the sake of clarity. It can be omitted since blockfactory::core::Block::terminate already provides the same dummy implementation. bool SignalMath :: terminate ( const blockfactory :: core :: BlockInformation * /*blockInfo*/ ) { return true ; } Implement the plugin factory \u00b6 A plugin library usually contains multiple classes used for multiple Blocks. The sharedlibpp tool for plugins requires declaring what classes are part of the plugin. This operation is done in the ./include/Factory.cpp file: #include \"SignalMath.h\" // Class factory API #include <shlibpp/SharedLibraryClassApi.h> // Add the example::SignalMath class to the plugin factory SHLIBPP_DEFINE_SHARED_SUBCLASS ( SignalMath , example :: SignalMath , blockfactory :: core :: Block ); The SHLIBPP_DEFINE_SHARED_SUBCLASS macro needs the following three arguments: A label used to extract the class from the plugin library The class of the block The base class of the block The only interesting part here is the label. Keep this name in mind because we need to know it later in the Simulink section. If everything was properly done, the library is now ready and can be compiled again: cd build cmake --build . Tip Simulink will open this library at the beginning of the simulation loop and it needs to be found in the filesystem. The BlockFactory search path can be configured by setting the BLOCKFACTORY_PLUGIN_PATH environment variable: GNU/Linux and macOS export BLOCKFACTORY_PLUGIN_PATH=<build folder absolute path> Windows $env:BLOCKFACTORY_PLUGIN_PATH = \"<build folder absolute path>\"; Matlab and Simulink \u00b6 Once the C++ library is ready, the class can be wrapped by a Simulink Block. If, as in this case, there's no existing Simulink Library to which the new block can be added, some extra step to create a new one is necessary. We're going to store the files discussed in this section in the ./matlab folder, obtaining at the end the following project structure: . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u251c\u2500\u2500 matlab \u2502 \u251c\u2500\u2500 ExampleToolbox.slx \u2502 \u251c\u2500\u2500 Model.mdl \u2502 \u2514\u2500\u2500 slblocks.m \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp ExampleToolbox.slx is the Simulink Library containing our new Signal Math Block. slblocks.m is a m-script necessary for loading external Simulink Libraries into the Simulink Library Browser . Model.mdl is a Simulink Model for testing the Block. Create an new Simulink Library \u00b6 The first step is creating a new Simulink Library. Open the Simulink Start Page and create a Blank Library. Save it in ./matlab/ExampleToolbox.slx . In order to populate the Simulink Library Browser , you need to create a slblocks.m file with the following content: function blkStruct = slblocks Browser . Library = 'ExampleToolbox' ; Browser . Name = 'Example Toolbox' ; Browser . IsFlat = 0 ; blkStruct . Browser = Browser ; As explained in the official documentation , we also need to modify a property of the library file: >> set_param ( 'ExampleToolbox' , 'EnableLBRepository' , 'on' ); If you followed these steps, the new library should be ready. Be sure that the ./matlab folder is in the Matlab path , then open the Simulink Library Browser and press F5 . You should now see the empty Example Toolbox entry. Note In order to add a folder to the path , you can either browse it from the Matlab tree view making it the current folder, or executing addpath('/path/of/the/folder') . Find more details at What Is the MATLAB Search Path? . Info Every time you close the library, Matlab locks it. Press the lock icon in the bottom left corner to unlock the library. Add a block \u00b6 Open the library and add a new S-Function block with the following parameters: The S-function name is the name of the generic S-Function that BlockFactory provides The S-function parameters are the parameters passed to the S-Function. The first two are required by blockfactory::core::Block , and the third one is the parameter of our example::SignalMath class: 'SignalMath' is the label we used in Factory.cpp when we registered our class. 'ExampleToolbox' is the name of the plugin library. It must match the OUTPUT_NAME we assigned to the target in CMakeLists.txt . 'Addition' is the kind of operation we want this block to perform. Press OK and save the library. If you insert wrong information, like a wrong number of parameters or parameters with a wrong type or content, the bfError s we added in the C++ class should provide more details (try it, a new popup error message should open). Create a test Simulink Model \u00b6 Now it's time for finally testing all our work. Create a new Blank Model and populate it with the following blocks: Then press the Play icon, and the Display connected to the block output should show the result of the addition. Create a block mask \u00b6 The type of the operation is defined as a parameter of the S-Function block. It is not very intuitive changing it in this way. Beyond the effort of changing the string, we should remember exactly what parameter the block accepts. This limitation can be overcome by masking the block, that means providing it a GUI. Right-click the block from the Example Toolbox library and press Mask > Create Mask . In the Icon & Ports tab, fill the Icon drawing commands with: disp ( 'Signal Math' ) port_label ( 'input' , 1 , 'Input 1' ) port_label ( 'input' , 2 , 'Input 2' ) port_label ( 'output' , 1 , 'Output' ) Then, in the Parameters & Dialog tab, add a Popup and fill it obtaining the following status: Note Note that we unchecked the Evaluate attribute. When a Popup is not evaluated, its associated variable ( operation in this case) will contain the string of the selected option. Instead, if it is evaluated, it contains a 0-based index. Save the library and substitute the new Block in the Simulink Model. You can now select the operation double-clicking the block and changing the popup menu entry. Final comments \u00b6 BlockFactory provides great abstraction capabilities for wrapping C and C++ algorithms to Simulink Blocks. You don't need to be a Simulink expert for this kind of operation, all the machinery is hidden under the hood. Possibilities are endless. We are eager to hear your feedback! If you find bugs or want to propose enhancements, please fill a new Issue .","title":"Create a new library"},{"location":"create_new_library/#how-to-create-a-new-library","text":"This guide describes how to use BlockFactory for creating a new toolbox Toolbox Example . It will contain a single block Signal math with the following specifications: Accepts two input signals Performs element-wise operations: sum, subtraction, multiplication Allows to select the operation with a user friendly GUI (mask) Produces an output signal with the result of the operation Despite it is a very trivial example, it shows how to structure both the C++ and the Matlab components of a toolbox. From this starting point is then possible to build more complex architectures which might need e.g. to be split in many parts or to link against third-party libraries. Toolbox Example project You can find the files of this example in the example folder.","title":"How to create a new library"},{"location":"create_new_library/#introduction","text":"Before jumping in the example of this tutorial, in this section you will find helpful information useful to grasp the key ideas about the toolbox and a refreshing of common terms and patterns used in programming.","title":"Introduction"},{"location":"create_new_library/#algorithm-specifications","text":"The execution of a generic algorithm can be split in the following basic phases: Configuration Initialization Step Termination In the configuration phase the algorithm can, for instance, read parameters and specify details about its inputs and outputs. During the initialization it might need to allocate resources. When everything is ready, the simulation starts and on every cycle of the loop the algorithm computes a step. Before finishing the simulation, in the termination step the resources that are not anymore needed can be deallocated and final operations can be executed.","title":"Algorithm specifications"},{"location":"create_new_library/#terminology","text":"There are few key components which are part of the core infrastructure, and it is important they are clear from the very beginning. Note This project has strong roots with Simulink. Despite it is not anymore strictly related to it, the structure keeps as inheritance its terminology.","title":"Terminology"},{"location":"create_new_library/#block","text":"The Block is the main component of the toolbox. You may think of it as a wrapper for a generic algorithm. It provides support of all the phases discussed above.","title":"Block"},{"location":"create_new_library/#port","text":"Blocks need to interface with the outside for reading input data and writing their results. Ports are attached to the Block and let data flow in and out from it. They have properties like the accepted data type and they are characterized by a size.","title":"Port"},{"location":"create_new_library/#signal","text":"A Signal is the generalization of a buffer. It can be plugged to multiple Ports and allows sharing data between them. Similarly to Ports, a Signal has a data type and a width. When a Signal is connected to a Port, their dimension must match.","title":"Signal"},{"location":"create_new_library/#engine","text":"The engine is the framework that calls and executes the code implementing the Blocks. We currently provide support for Simulink and Simulink Coder. Alternative engines might be Scilab or even standalone C++ code.","title":"Engine"},{"location":"create_new_library/#blockinformation","text":"BlockInformation is the interface between a Block and the engine that executes its code. Despite blocks are not aware of what engine is executing them, blocks and engine need to exchange information such as user parameters and Port data. BlockInformation provides methods for setting and getting this piece of information.","title":"BlockInformation"},{"location":"create_new_library/#simulink-block","text":"A Simulink Block is the wrapper of a (C++) Block. It provides a visual representation of it, with input and output ports and gives the possibility to connect it with other Simulink blocks through signals. The terms above come from this representation and map it to C++.","title":"Simulink Block"},{"location":"create_new_library/#simulink-model","text":"A Simulink Model is a project composed of a set of Simulink Blocks interconnected by Signals.","title":"Simulink Model"},{"location":"create_new_library/#simulink-library","text":"A Simulink Library is a container of a set of Blocks that populates the Simulink Library Browser . Every toolbox must be shipped with an associated Simulink Library file in order to expose its Blocks.","title":"Simulink Library"},{"location":"create_new_library/#s-function","text":"There are many types of functions for implementing an algorithm wrapped by a Simulink Block. In Matlab terminology, these functions are referred as S-Functions . You can read more about the supported types in What type of S-Function should you use . In short S-Functions provide a sort of interface (through C callbacks) where a given number of functions need to be implemented. Simulink knows the name of these functions and calls them on demand.","title":"S-Function"},{"location":"create_new_library/#block-mask","text":"A Simulink Block is just a square with input and output ports. It is possible to \"mask\" a Simulink Block in order to provide a user-friendly GUI that can be useful e.g. for setting Block parameters. The mask may contain buttons, sliders, check boxes, dropdown menus, etc.","title":"Block Mask"},{"location":"create_new_library/#software-library","text":"A library is a file containing compiled code (functions, classes, constants, etc.) which cannot be executed standalone. It can be either static or dynamic . Static libraries are meant to be embedded inside the executable that calls their symbols, instead the code of dynamic libraries (also called shared libraries) is only referenced inside the executable and called when needed. To grasp better this difference, if multiple executables link against the same static library, the same code is embedded inside all of them, resulting in bigger executables and code duplication. A dynamic library object instead can be shared by multiple executables that need only to know its location in the filesystem and which symbols it provide. Info You can find more detailed information about software libraries and linkers at this link .","title":"Software library"},{"location":"create_new_library/#plugin-library","text":"A plugin library is a particular type of a dynamic library. An executable can load dynamic libraries either at load time, i.e. when the executable is launched, or at run time, i.e. when needed during the execution. The libraries that can be loaded during run time are referred as plugins. Info On UNIX systems the load of a plugin is executed by a dlopen call","title":"Plugin Library"},{"location":"create_new_library/#overview-of-simulink-execution","text":"BlockFactory provides a framework capable of loading during runtime shared libraries (plugins). When the Simulink simulation starts, its engine assigns a deterministic order to the blocks of the Simulink Model. If one of these blocks is not contained in the default toolboxes provided by Mathworks, it needs to be associated to a S-Function that implements its logic. The toolbox provides a streamlined approach to implement these functions without the need of being an expert of the complex Simulink APIs. The blocks of our library are implemented in Simulink using the following S-Function block: For the time being, what you need to know is that the name of the plugin library generated from the C++ code will be stored in the S-function parameters field of the block mask. We provide a generic Level-2 MEX S-Function that reads this parameter and uses the library name name to dynamically load the dynamic library that contains the block's code. After the library is found in the filesystem and successfully loaded, Simulink allocates an object of the C++ class associated to the block functionality. Again, this information (the class name) is passed in the S-function parameters field of the block mask.","title":"Overview of Simulink execution"},{"location":"create_new_library/#develop-the-c-plugin","text":"You already learned that Blocks are no more than regular C++ classes. They are not an exception, in fact all the components discussed until now are mapped to C++ classes or interfaces ( abstract classes ). The following resources provide further information about them: Blocks are implementations of the blockfactory::core::Block interface BlockInformation is defined in the blockfactory::core::BlockInformation interface Signals are mapped to the blockfactory::core::Signal class Blocks parameters are mapped to the blockfactory::core::Parameter class We need the following folder structure for the C++ project. Create already the empty files so the project can compile from the very first attempt. . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp Info All the path of this tutorial will be relative to the root folder of the project. This means that if the directory tree above is stored in /home/foo/tutorial , when you read to go the ./build directory it means /home/foo/tutorial/build . Tip Bear in mind that this C++ class is independent from Simulink. Potentially, it can be called by a standalone C++ executable. Tip It is not mandatory to implement a new class for every Simulink Block. If they share a lot of code, a single class can be referenced by multiple Simulink Blocks and its behavior can be selected using parameters. Tip You can use all the external libraries you want to implement the code of this class.","title":"Develop the C++ plugin"},{"location":"create_new_library/#cmake-project-for-compiling-the-library","text":"You are free to use your favourite tool for compiling the project. We recommend CMake. If you are not an expert user of this tool, just follow the steps. The comments in the file should be enough to understand what it is happening. Fill the file CMakeLists.txt with the following content: cmake_minimum_required ( VERSION 3.5 ) project ( ExampleToolbox LANGUAGES CXX VERSION 0.1 ) # C++ standard set ( CMAKE_CXX_STANDARD 14 ) set ( CMAKE_CXX_STANDARD_REQUIRED ON ) # Export all symbols in Windows set ( CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON ) # Utility for defining install folders include ( GNUInstallDirs ) # Tweak linker flags in Linux. # Matlab is very strict on missing symbols and by default ld do not warn if # something is missing. if ( UNIX AND NOT APPLE ) get_filename_component ( LINKER_BIN ${ CMAKE_LINKER } NAME ) if ( ${ LINKER_BIN } STREQUAL \"ld\" ) set ( CMAKE_SHARED_LINKER_FLAGS \"-Wl,--unresolved-symbols=report-all\" ) endif () endif () # =========== # C++ LIBRARY # =========== # Find the needed BlockFactory components: # - \"Core\" contains the core classes such as Block and Signal # - \"Simulink\" is required at runtime for loading the library from Simulink find_package ( BlockFactory REQUIRED COMPONENTS Core OPTIONAL_COMPONENTS Simulink ) # Create the plugin library. This must be a SHARED library. add_library ( ExampleToolbox SHARED include/SignalMath.h src/SignalMath.cpp src/Factory.cpp ) # Manually set the name of the output library. This is not required and it # is done only for sake of clarity. set_target_properties ( ExampleToolbox PROPERTIES OUTPUT_NAME \"ExampleToolbox\" ) # Link the library with the Core component containing the core classes target_link_libraries ( ExampleToolbox PRIVATE BlockFactory::Core ) # Setup the include directories target_include_directories ( ExampleToolbox PRIVATE $< BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include > ) Note If your library needs to link against other libraries, use find_package to load their targets and then add them to the target_link_libraries directive. Compiling instructions From the root folder of the project, execute: GNU/Linux and macOS mkdir build cd build cmake .. cmake --build . Windows mkdir build cd build cmake .. cmake --build . --config Release You should now find in the ./build directories a new library file, which depending on your OS is: libExampleToolbox.so on Linux libExampleToolbox.dylib on macOS ExampleToolbox.dll on Windows This is the toolbox's plugin library which is loaded during runtime by the active Engine.","title":"CMake project for compiling the library"},{"location":"create_new_library/#implement-the-block-logic","text":"The only Signal math block of our new toolbox will be implemented in a example::SignalMath C++ class.","title":"Implement the block logic"},{"location":"create_new_library/#header","text":"Here below the ./include/SignalMath.h header. Given the simple logic it should be straightforward to understand. The class inherits from the blockfactory::core::Block interface and implements some of its methods. Info The only mandatory method to implement is the blockfactory::core::Block::output . By default the other methods are dummy and they always return true . #ifndef EXAMPLE_SIGNALMATH_H #define EXAMPLE_SIGNALMATH_H #include <BlockFactory/Core/Block.h> #include <BlockFactory/Core/BlockInformation.h> #include <memory> #include <string> namespace example { class SignalMath ; } // namespace example class example :: SignalMath : public blockfactory :: core :: Block { private : enum class Operation { ADDITION , SUBTRACTION , MULTIPLICATION , }; Operation m_operation ; public : static const std :: string ClassName ; SignalMath () = default ; ~ SignalMath () override = default ; unsigned numberOfParameters () override ; bool parseParameters ( blockfactory :: core :: BlockInformation * blockInfo ) override ; bool configureSizeAndPorts ( blockfactory :: core :: BlockInformation * blockInfo ) override ; bool initialize ( blockfactory :: core :: BlockInformation * blockInfo ) override ; bool output ( const blockfactory :: core :: BlockInformation * blockInfo ) override ; bool terminate ( const blockfactory :: core :: BlockInformation * blockInfo ) override ; }; #endif // EXAMPLE_SIGNALMATH_H The ./src/SignalMath.cpp file is more interesting, let's split it in chunks.","title":"Header"},{"location":"create_new_library/#parameters","text":"If you recall, BlockInformation is used by the Block for interfacing with the Engine. When this code is executed inside Simulink, the blockfactory::core::SimulinkBlockInformation implementation will perform the required operations calling Simulink APIs. #include \"SignalMath.h\" #include <BlockFactory/Core/Log.h> #include <BlockFactory/Core/Parameter.h> #include <BlockFactory/Core/Signal.h> using namespace example ; unsigned SignalMath :: numberOfParameters () { // The base blockfactory::core::Block class needs parameters (e.g. the ClassName). // You must specify here how many more parameters this class needs. // Our example needs just one more: the operation to perform. return Block :: numberOfParameters () + 1 ; } // This method should let BlockInformation know the parameters metadata. // BlockFactory will use this information to gather the parameters from the active engine. bool SignalMath :: parseParameters ( blockfactory :: core :: BlockInformation * blockInfo ) { // Initialize information for our only parameter int rows = 1 ; int cols = 1 ; std :: string name = \"Operation\" ; // This label is used later to access the paramemeter unsigned index = Block :: numberOfParameters (); // Indices start from 0 auto type = blockfactory :: core :: ParameterType :: STRING ; // Create the parameter blockfactory :: core :: ParameterMetadata parameterMetadata ( type , index , rows , cols , name ); // Add the parameter metadata into the BlockInformation if ( ! blockInfo -> addParameterMetadata ( parameterMetadata )) { bfError << \"Failed to store parameter metadata\" ; return false ; } // Ask to the BlockInformation interface to parse the parameters and store them into // the protected m_parameters member of the parent blockfactory::core::Block class. bool paramParsedOk = blockInfo -> parseParameters ( m_parameters ); // Return the outcome of the parameter parsing. // If the parsing fails, the execution stops. return paramParsedOk ; }","title":"Parameters"},{"location":"create_new_library/#configuration","text":"The configuration of the Block is performed in the following steps: The base class needs to be configured. It needs some parameters (e.g. the class name and the library name) and this call asks the Engine to parse them. The ports of the Block need to be defined. In this example the size is set as dynamic so that it accepts signals with any width. The data is then sent to the Engine through the BlockInformation interface. Info If needed, parameters can be accessed from this step. Refer to the initialization phase to understand how to gather them. Signal size Simulink has the support of inheriting the port size from the signal size, though use this feature only when strictly needed. In complex Simulink Models the Engine might have difficulties to execute this size propagation, and fixing the Port sizes provides helpful constraints (especially for blocks with only outputs) Important Be careful on memory allocations during this step. A temporary object is created only for configuration means, and then destroyed. All the allocated memory will be hereby deleted. bool SignalMath :: configureSizeAndPorts ( blockfactory :: core :: BlockInformation * blockInfo ) { // The base blockfactory::core::Block class needs to be configured first if ( ! blockfactory :: core :: Block :: configureSizeAndPorts ( blockInfo )) { return false ; } // Create object that store input and output ports information blockfactory :: core :: Port :: Info input1 { /*portIndex=*/ 0 , std :: vector < int > { blockfactory :: core :: Port :: DynamicSize }, blockfactory :: core :: Port :: DataType :: DOUBLE }; blockfactory :: core :: Port :: Info input2 { /*portIndex=*/ 1 , std :: vector < int > { blockfactory :: core :: Port :: DynamicSize }, blockfactory :: core :: Port :: DataType :: DOUBLE }; blockfactory :: core :: Port :: Info output { /*portIndex=*/ 0 , std :: vector < int > { blockfactory :: core :: Port :: DynamicSize }, blockfactory :: core :: Port :: DataType :: DOUBLE }; // Store together the port information objects blockfactory :: core :: InputPortsInfo inputPortInfo ; blockfactory :: core :: OutputPortsInfo outputPortInfo ; inputPortInfo . push_back ( input1 ); inputPortInfo . push_back ( input2 ); outputPortInfo . push_back ( output ); // Store the port information into the BlockInformation if ( ! blockInfo -> setPortsInfo ( inputPortInfo , outputPortInfo )) { bfError << \"Failed to configure input / output ports\" ; return false ; } return true ; }","title":"Configuration"},{"location":"create_new_library/#initialization","text":"Info Starting from this step, memory persistence is guaranteed. In the initialisation step, the input parameter that defines the operation is parsed. In this example the parameter is passed as a string. In the header a new enum class Operation was defined and here the related private member is properly initialised. Additional checks can be added, i.e. testing that both ports have the same width given that a dynamic size was previously assigned. Info In this case there's no need to allocate memory. If your class has buffers to initialise, this is the right time to do it. bool SignalMath :: initialize ( blockfactory :: core :: BlockInformation * blockInfo ) { // The base blockfactory::core::Block class need to be initialized first if ( ! Block :: initialize ( blockInfo )) { return false ; } // Parse the parameters if ( ! SignalMath :: parseParameters ( blockInfo )) { bfError << \"Failed to parse parameters.\" ; return false ; } // Read the Operation parameter and store it as a private member std :: string operation ; if ( ! m_parameters . getParameter ( \"Operation\" , operation )) { bfError << \"Failed to parse Operation parameter\" ; return false ; } // Check the content of the parameter if ( operation == \"Addition\" ) { m_operation = Operation :: ADDITION ; } else if ( operation == \"Subtraction\" ) { m_operation = Operation :: SUBTRACTION ; } else if ( operation == \"Multiplication\" ) { m_operation = Operation :: MULTIPLICATION ; ; } else { bfError << \"Operation \" << operation << \" not recognized\" ; return false ; } // Check that the size of the input signals match if ( blockInfo -> getInputPortWidth ( /*index=*/ 0 ) != blockInfo -> getInputPortWidth ( /*index=*/ 1 )) { bfError << \"Input signals widths do not match\" ; return false ; } return true ; }","title":"Initialization"},{"location":"create_new_library/#output","text":"The output method is where the real algorithm is implemented. The Signals are firstly gathered from the Engine using their index. The classes blockfactory::core::InputSignalPtr and blockfactory::core::OutputSignalPtr are particular typedef of the blockfactory::core::Signal class and they have the same methods. In the for loop the configured operation is performed and the result stored in the output signal. Note Note that input signals are read-only and accessed in C++ as const object. You can store data only to the output signals objects. bool SignalMath :: output ( const blockfactory :: core :: BlockInformation * blockInfo ) { // Get the input signals blockfactory :: core :: InputSignalPtr input1 = blockInfo -> getInputPortSignal ( /*index=*/ 0 ); blockfactory :: core :: InputSignalPtr input2 = blockInfo -> getInputPortSignal ( /*index=*/ 1 ); // Get the output signal blockfactory :: core :: OutputSignalPtr output = blockInfo -> getOutputPortSignal ( /*index=*/ 0 ); // Check the signal validity if ( ! input1 || ! input2 || ! output ) { bfError << \"Signals not valid\" ; return false ; } // Check the width of the output signal. // This check is recommended for dynamically sized signals since the engine might // fail to propagate the right dimensions. if ( output -> getWidth () != input1 -> getWidth ()) { bfError << \"Output signal has a width of \" << output -> getWidth () << \" while input signals have a width of \" << input1 -> getWidth (); return false ; } // Perform the given operation for ( size_t i = 0 ; i < output -> getWidth (); ++ i ) { switch ( m_operation ) { case Operation :: ADDITION : output -> set ( i , input1 -> get < double > ( i ) + input2 -> get < double > ( i )); break ; case Operation :: SUBTRACTION : output -> set ( i , input1 -> get < double > ( i ) - input2 -> get < double > ( i )); break ; case Operation :: MULTIPLICATION : output -> set ( i , input1 -> get < double > ( i ) * input2 -> get < double > ( i )); break ; } } return true ; }","title":"Output"},{"location":"create_new_library/#terminate","text":"Given the simplicity of our Block, the terminate step is a dummy implementation. This method is reported just for the sake of clarity. It can be omitted since blockfactory::core::Block::terminate already provides the same dummy implementation. bool SignalMath :: terminate ( const blockfactory :: core :: BlockInformation * /*blockInfo*/ ) { return true ; }","title":"Terminate"},{"location":"create_new_library/#implement-the-plugin-factory","text":"A plugin library usually contains multiple classes used for multiple Blocks. The sharedlibpp tool for plugins requires declaring what classes are part of the plugin. This operation is done in the ./include/Factory.cpp file: #include \"SignalMath.h\" // Class factory API #include <shlibpp/SharedLibraryClassApi.h> // Add the example::SignalMath class to the plugin factory SHLIBPP_DEFINE_SHARED_SUBCLASS ( SignalMath , example :: SignalMath , blockfactory :: core :: Block ); The SHLIBPP_DEFINE_SHARED_SUBCLASS macro needs the following three arguments: A label used to extract the class from the plugin library The class of the block The base class of the block The only interesting part here is the label. Keep this name in mind because we need to know it later in the Simulink section. If everything was properly done, the library is now ready and can be compiled again: cd build cmake --build . Tip Simulink will open this library at the beginning of the simulation loop and it needs to be found in the filesystem. The BlockFactory search path can be configured by setting the BLOCKFACTORY_PLUGIN_PATH environment variable: GNU/Linux and macOS export BLOCKFACTORY_PLUGIN_PATH=<build folder absolute path> Windows $env:BLOCKFACTORY_PLUGIN_PATH = \"<build folder absolute path>\";","title":"Implement the plugin factory"},{"location":"create_new_library/#matlab-and-simulink","text":"Once the C++ library is ready, the class can be wrapped by a Simulink Block. If, as in this case, there's no existing Simulink Library to which the new block can be added, some extra step to create a new one is necessary. We're going to store the files discussed in this section in the ./matlab folder, obtaining at the end the following project structure: . \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 SignalMath.h \u251c\u2500\u2500 matlab \u2502 \u251c\u2500\u2500 ExampleToolbox.slx \u2502 \u251c\u2500\u2500 Model.mdl \u2502 \u2514\u2500\u2500 slblocks.m \u2514\u2500\u2500 src \u251c\u2500\u2500 Factory.cpp \u2514\u2500\u2500 SignalMath.cpp ExampleToolbox.slx is the Simulink Library containing our new Signal Math Block. slblocks.m is a m-script necessary for loading external Simulink Libraries into the Simulink Library Browser . Model.mdl is a Simulink Model for testing the Block.","title":"Matlab and Simulink"},{"location":"create_new_library/#create-an-new-simulink-library","text":"The first step is creating a new Simulink Library. Open the Simulink Start Page and create a Blank Library. Save it in ./matlab/ExampleToolbox.slx . In order to populate the Simulink Library Browser , you need to create a slblocks.m file with the following content: function blkStruct = slblocks Browser . Library = 'ExampleToolbox' ; Browser . Name = 'Example Toolbox' ; Browser . IsFlat = 0 ; blkStruct . Browser = Browser ; As explained in the official documentation , we also need to modify a property of the library file: >> set_param ( 'ExampleToolbox' , 'EnableLBRepository' , 'on' ); If you followed these steps, the new library should be ready. Be sure that the ./matlab folder is in the Matlab path , then open the Simulink Library Browser and press F5 . You should now see the empty Example Toolbox entry. Note In order to add a folder to the path , you can either browse it from the Matlab tree view making it the current folder, or executing addpath('/path/of/the/folder') . Find more details at What Is the MATLAB Search Path? . Info Every time you close the library, Matlab locks it. Press the lock icon in the bottom left corner to unlock the library.","title":"Create an new Simulink Library"},{"location":"create_new_library/#add-a-block","text":"Open the library and add a new S-Function block with the following parameters: The S-function name is the name of the generic S-Function that BlockFactory provides The S-function parameters are the parameters passed to the S-Function. The first two are required by blockfactory::core::Block , and the third one is the parameter of our example::SignalMath class: 'SignalMath' is the label we used in Factory.cpp when we registered our class. 'ExampleToolbox' is the name of the plugin library. It must match the OUTPUT_NAME we assigned to the target in CMakeLists.txt . 'Addition' is the kind of operation we want this block to perform. Press OK and save the library. If you insert wrong information, like a wrong number of parameters or parameters with a wrong type or content, the bfError s we added in the C++ class should provide more details (try it, a new popup error message should open).","title":"Add a block"},{"location":"create_new_library/#create-a-test-simulink-model","text":"Now it's time for finally testing all our work. Create a new Blank Model and populate it with the following blocks: Then press the Play icon, and the Display connected to the block output should show the result of the addition.","title":"Create a test Simulink Model"},{"location":"create_new_library/#create-a-block-mask","text":"The type of the operation is defined as a parameter of the S-Function block. It is not very intuitive changing it in this way. Beyond the effort of changing the string, we should remember exactly what parameter the block accepts. This limitation can be overcome by masking the block, that means providing it a GUI. Right-click the block from the Example Toolbox library and press Mask > Create Mask . In the Icon & Ports tab, fill the Icon drawing commands with: disp ( 'Signal Math' ) port_label ( 'input' , 1 , 'Input 1' ) port_label ( 'input' , 2 , 'Input 2' ) port_label ( 'output' , 1 , 'Output' ) Then, in the Parameters & Dialog tab, add a Popup and fill it obtaining the following status: Note Note that we unchecked the Evaluate attribute. When a Popup is not evaluated, its associated variable ( operation in this case) will contain the string of the selected option. Instead, if it is evaluated, it contains a 0-based index. Save the library and substitute the new Block in the Simulink Model. You can now select the operation double-clicking the block and changing the popup menu entry.","title":"Create a block mask"},{"location":"create_new_library/#final-comments","text":"BlockFactory provides great abstraction capabilities for wrapping C and C++ algorithms to Simulink Blocks. You don't need to be a Simulink expert for this kind of operation, all the machinery is hidden under the hood. Possibilities are endless. We are eager to hear your feedback! If you find bugs or want to propose enhancements, please fill a new Issue .","title":"Final comments"},{"location":"install/","text":"Install \u00b6 Disclaimer BlockFactory has been widely tested on Ubuntu 16:04 and Ubuntu 18.04 with Matlab R2017b . If you face any issue either with your OS or Matlab version, please submit an Issue . Requirements \u00b6 Supported Operating Systems GNU/Linux macOS Windows C++14 compiler CMake 3.5 BlockFactory provides three components, listed here below with their dependencies. If a component dependency is not found, the component is not built. Core SimulinkCoder Simulink Dependencies ~ ~ - Matlab - Simulink Note Simulink Coder is not a build dependency of the SimulinkCoder component. Of course, you must have it if you want to generate C++ code from a Simulink model. Installation \u00b6 If all the dependencies are met, proceed with the following instructions: From sources Substitute to <install-prefix> the absolute path where you want to install the project. GNU/Linux and macOS git clone https://github.com/robotology/blockfactory.git mkdir -p blockfactory/build && cd blockfactory/build cmake .. -DCMAKE_INSTALL_PREFIX=<install-prefix> cmake --build . cmake --build . --target install Windows git clone https://github.com/robotology/blockfactory.git mkdir -p blockfactory/build && cd blockfactory/build cmake .. -DCMAKE_INSTALL_PREFIX=<install-prefix> cmake --build . --config Release cmake --build . --config Release --target install Configuration \u00b6 Matlab \u00b6 BlockFactory provides the support of: Simulink by shipping a generic MEX Level-2 S-Function S-Functions Simulink Coder by shipping a TLC file to achieve Wrapper Inlined S-Functions These two files are installed in the <install-prefix>/mex folder, which should be added to the Matlab search path . Plugins \u00b6 The archictecture of BlockFactory is based on a plugin system. The libraries containing the blocks must be found in the filesystem. Add to the following environment variable all the folders that contain BlockFactory plugins: Environment GNU/Linux and macOS export BLOCKFACTORY_PLUGIN_PATH=/installfolder1/subfolder1/blockfactory:/installfolder2/subfolder2/blockfactory/:<...> Windows $env:BLOCKFACTORY_PLUGIN_PATH = \"C:\\installfolder1\\subfolder1\\blockfactory;C:\\installfolder2\\subfolder2\\blockfactory:<...>\";","title":"Install"},{"location":"install/#install","text":"Disclaimer BlockFactory has been widely tested on Ubuntu 16:04 and Ubuntu 18.04 with Matlab R2017b . If you face any issue either with your OS or Matlab version, please submit an Issue .","title":"Install"},{"location":"install/#requirements","text":"Supported Operating Systems GNU/Linux macOS Windows C++14 compiler CMake 3.5 BlockFactory provides three components, listed here below with their dependencies. If a component dependency is not found, the component is not built. Core SimulinkCoder Simulink Dependencies ~ ~ - Matlab - Simulink Note Simulink Coder is not a build dependency of the SimulinkCoder component. Of course, you must have it if you want to generate C++ code from a Simulink model.","title":"Requirements"},{"location":"install/#installation","text":"If all the dependencies are met, proceed with the following instructions: From sources Substitute to <install-prefix> the absolute path where you want to install the project. GNU/Linux and macOS git clone https://github.com/robotology/blockfactory.git mkdir -p blockfactory/build && cd blockfactory/build cmake .. -DCMAKE_INSTALL_PREFIX=<install-prefix> cmake --build . cmake --build . --target install Windows git clone https://github.com/robotology/blockfactory.git mkdir -p blockfactory/build && cd blockfactory/build cmake .. -DCMAKE_INSTALL_PREFIX=<install-prefix> cmake --build . --config Release cmake --build . --config Release --target install","title":"Installation"},{"location":"install/#configuration","text":"","title":"Configuration"},{"location":"install/#matlab","text":"BlockFactory provides the support of: Simulink by shipping a generic MEX Level-2 S-Function S-Functions Simulink Coder by shipping a TLC file to achieve Wrapper Inlined S-Functions These two files are installed in the <install-prefix>/mex folder, which should be added to the Matlab search path .","title":"Matlab"},{"location":"install/#plugins","text":"The archictecture of BlockFactory is based on a plugin system. The libraries containing the blocks must be found in the filesystem. Add to the following environment variable all the folders that contain BlockFactory plugins: Environment GNU/Linux and macOS export BLOCKFACTORY_PLUGIN_PATH=/installfolder1/subfolder1/blockfactory:/installfolder2/subfolder2/blockfactory/:<...> Windows $env:BLOCKFACTORY_PLUGIN_PATH = \"C:\\installfolder1\\subfolder1\\blockfactory;C:\\installfolder2\\subfolder2\\blockfactory:<...>\";","title":"Plugins"},{"location":"license/","text":"LGPL v2.1 or any later version \u00b6 Copyright (C) 2019 Istituto Italiano di Tecnologia - iCub Facility This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA","title":"License"},{"location":"license/#lgpl-v21-or-any-later-version","text":"Copyright (C) 2019 Istituto Italiano di Tecnologia - iCub Facility This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA","title":"LGPL v2.1 or any later version"},{"location":"tutorial_intro/","text":"Introduction \u00b6 One of the big advantages of dataflow programming resides in the visual programming tools that are usually associated to it. Blockfactory, however, mainly targets developers of such frameworks, aiming to simplify their learning curve that too often is very steep. We at the Italian Institute of Technology are mainly researchers and PhD students, and the possibility of translating in short time volatile ideas to a first prototypical implementation is paramount. BlockFactory represents an excellent tool for prototyping. By exploiting its general purpose features, we can expose every C++ algorithm we may need in very short time to other users that just have to use the new blocks that wrap their functionalities to a very high abstraction level. Though, this is only the first step of development. When an arbitrarily complex model (usually in Simulink) becomes mature enough, we would also like to deploy it to the target platform. With the help of Simulink Coder, the models created with blocks based on BlockFactory can be translated to a C++ library passing through a code autogeneration process. At this point, the library can be compiled (or cross-compiled) and effectively deployed to the target device. If you want to learn how to exploit our framework to create something similar for your own applications, you can start from here: How to create a new Simulink Library How to autogenerate C++ code","title":"Introduction"},{"location":"tutorial_intro/#introduction","text":"One of the big advantages of dataflow programming resides in the visual programming tools that are usually associated to it. Blockfactory, however, mainly targets developers of such frameworks, aiming to simplify their learning curve that too often is very steep. We at the Italian Institute of Technology are mainly researchers and PhD students, and the possibility of translating in short time volatile ideas to a first prototypical implementation is paramount. BlockFactory represents an excellent tool for prototyping. By exploiting its general purpose features, we can expose every C++ algorithm we may need in very short time to other users that just have to use the new blocks that wrap their functionalities to a very high abstraction level. Though, this is only the first step of development. When an arbitrarily complex model (usually in Simulink) becomes mature enough, we would also like to deploy it to the target platform. With the help of Simulink Coder, the models created with blocks based on BlockFactory can be translated to a C++ library passing through a code autogeneration process. At this point, the library can be compiled (or cross-compiled) and effectively deployed to the target device. If you want to learn how to exploit our framework to create something similar for your own applications, you can start from here: How to create a new Simulink Library How to autogenerate C++ code","title":"Introduction"}]}