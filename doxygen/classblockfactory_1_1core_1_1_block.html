<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>blockfactory: blockfactory::core::Block Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">blockfactory
   &#160;<span id="projectnumber">0.8</span>
   </div>
   <div id="projectbrief">A framework for wrapping algorithms for dataflow programming</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classblockfactory_1_1core_1_1_block.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classblockfactory_1_1core_1_1_block-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">blockfactory::core::Block Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic abstract class for wrapping generic algorithms.  
 <a href="classblockfactory_1_1core_1_1_block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_block_8h_source.html">Block.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic abstract class for wrapping generic algorithms. </p>
<h3>Rationale</h3>
<p>This class is aimed to wrap generic algorithms and it represents the most basic component of <code>BlockFactory</code>.</p>
<p>The entire execution of a generic algorithm can be split in the following major steps:</p>
<ul>
<li>Initialization: implemented with <a class="el" href="classblockfactory_1_1core_1_1_block.html#acfb40d2bd1d43f6e938452b198b6b5fd" title="Configure the input and output ports. ">core::Block::configureSizeAndPorts</a>, <a class="el" href="classblockfactory_1_1core_1_1_block.html#ac2f5743e10b9c8cb4c4cc4ce86d650b2" title="Initialize the block. ">core::Block::initialize</a></li>
<li>Execution: implemented with <a class="el" href="classblockfactory_1_1core_1_1_block.html#a86d686e8917840e9d90e3cae2fc7cf64" title="Compute the output of the block. ">core::Block::output</a></li>
<li>Termination: implemented with <a class="el" href="classblockfactory_1_1core_1_1_block.html#a2d662aeca0016ad63c8a1c7750c6c713" title="Cleanup block resources. ">core::Block::terminate</a></li>
</ul>
<p>Considering that the main aim of this framework at its beginning was the integration with Simulink, it contains other methods for exposing the algorithm as a Simulink block.</p>
<h3>Main concept</h3>
<p>A generic application is the composition of many algorithms sharing and processing each other data. Every algorithm is represented by a <a class="el" href="classblockfactory_1_1core_1_1_block.html" title="Basic abstract class for wrapping generic algorithms. ">core::Block</a>, and the data shared with other blocks is carried by <a class="el" href="classblockfactory_1_1core_1_1_signal.html" title="Class to access data shared by blocks, represented as signals. ">core::Signal</a>.</p>
<p>The block is generally unaware of the data that it will process, and it is only interested in knowing how many input / output signals are connected, their size and data type. Blocks have the concept of <em>ports</em>, which are the connections between external <a class="el" href="classblockfactory_1_1core_1_1_signal.html" title="Class to access data shared by blocks, represented as signals. ">core::Signal</a> and the block itself.</p>
<dl class="section remark"><dt>Remarks</dt><dd>A signal can be plugged to more than one port.</dd></dl>
<p>This kind of information is set by a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">core::BlockInformation</a> object, and it is specific to the framework where the algorithm runs (e.g. standalone C++ code, Simulink, etc).</p>
<p>Beyond this, an algorithm often needs parameters. This class provides functionalities to gather them in a <a class="el" href="classblockfactory_1_1core_1_1_parameters.html" title="Class for storing block&#39;s parameters. ">core::Parameters</a> object.</p>
<h3>Other information</h3>
<p>You can create a new block by deriving from this class and implementing at least all the abstract methods.</p>
<dl class="section note"><dt>Note</dt><dd>This block interface assumes that algorithms are represented as instantaneous systems, there is no default storage capability between different sampling times. However, concrete blocks can have buffers that retain previous data. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Despite some of the methods inside this class look Simulink-dependent, objects of this class are completely generic. In fact, <a class="el" href="classblockfactory_1_1core_1_1_block.html" title="Basic abstract class for wrapping generic algorithms. ">core::Block</a> only provides algorithm callbacks, and the operation to set input / output data is demanded to the <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">core::BlockInformation</a> interface. For what concerns Simulink, a <a class="el" href="classblockfactory_1_1mex_1_1_simulink_block_information.html" title="Simulink implementation of block information. ">mex::SimulinkBlockInformation</a> implementation is provided. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classblockfactory_1_1core_1_1_signal.html" title="Class to access data shared by blocks, represented as signals. ">core::Signal</a>, <a class="el" href="classblockfactory_1_1core_1_1_port.html" title="Class that stores port properties. ">core::Port</a>, <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">core::BlockInformation</a></dd></dl>
<h1><a class="anchor" id="block_parameters"></a>
Block Parameters</h1>
<table class="doxtable">
<tr>
<th>Type </th><th align="center">Index </th><th align="center">Rows </th><th align="center">Cols </th><th>Name  </th></tr>
<tr>
<td><a class="el" href="namespaceblockfactory_1_1core.html#ad94013a79fc17415d0793ce04afde8c2a63b588d5559f64f89a416e656880b949">ParameterType::STRING</a> </td><td align="center">0 </td><td align="center">1 </td><td align="center">1 </td><td>"className" </td></tr>
<tr>
<td><a class="el" href="namespaceblockfactory_1_1core.html#ad94013a79fc17415d0793ce04afde8c2a63b588d5559f64f89a416e656880b949">ParameterType::STRING</a> </td><td align="center">1 </td><td align="center">1 </td><td align="center">1 </td><td>"libName" </td></tr>
</table>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b4d459fe39915cbe85d738bb767d458"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a9b4d459fe39915cbe85d738bb767d458">~Block</a> ()=default</td></tr>
<tr class="memdesc:a9b4d459fe39915cbe85d738bb767d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a9b4d459fe39915cbe85d738bb767d458">More...</a><br /></td></tr>
<tr class="separator:a9b4d459fe39915cbe85d738bb767d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b0465b444ee55679c7602fe90b84fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#ae4b0465b444ee55679c7602fe90b84fe">getUniqueName</a> (const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo) const </td></tr>
<tr class="memdesc:ae4b0465b444ee55679c7602fe90b84fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique name of the block instance.  <a href="#ae4b0465b444ee55679c7602fe90b84fe">More...</a><br /></td></tr>
<tr class="separator:ae4b0465b444ee55679c7602fe90b84fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85176801eb52d1a350af994438f5b973"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a85176801eb52d1a350af994438f5b973">numberOfParameters</a> ()</td></tr>
<tr class="memdesc:a85176801eb52d1a350af994438f5b973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of configuration parameters needed by this block.  <a href="#a85176801eb52d1a350af994438f5b973">More...</a><br /></td></tr>
<tr class="separator:a85176801eb52d1a350af994438f5b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7870c7ff32f7f8c4f475baa18b7675e5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a7870c7ff32f7f8c4f475baa18b7675e5">additionalBlockOptions</a> ()</td></tr>
<tr class="memdesc:a7870c7ff32f7f8c4f475baa18b7675e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of additional block options.  <a href="#a7870c7ff32f7f8c4f475baa18b7675e5">More...</a><br /></td></tr>
<tr class="separator:a7870c7ff32f7f8c4f475baa18b7675e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90061447ea56e809f3e882b2c0d4a7c0"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a90061447ea56e809f3e882b2c0d4a7c0">numberOfDiscreteStates</a> ()</td></tr>
<tr class="memdesc:a90061447ea56e809f3e882b2c0d4a7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of discrete states of the block.  <a href="#a90061447ea56e809f3e882b2c0d4a7c0">More...</a><br /></td></tr>
<tr class="separator:a90061447ea56e809f3e882b2c0d4a7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917d00d0c7fb9d28ab4b37657add7639"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a917d00d0c7fb9d28ab4b37657add7639">numberOfContinuousStates</a> ()</td></tr>
<tr class="memdesc:a917d00d0c7fb9d28ab4b37657add7639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of continuous states of the block.  <a href="#a917d00d0c7fb9d28ab4b37657add7639">More...</a><br /></td></tr>
<tr class="separator:a917d00d0c7fb9d28ab4b37657add7639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba67e1154ce022506b4d3ad0760bd52"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a3ba67e1154ce022506b4d3ad0760bd52">updateDiscreteState</a> (const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:a3ba67e1154ce022506b4d3ad0760bd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internal discrete state.  <a href="#a3ba67e1154ce022506b4d3ad0760bd52">More...</a><br /></td></tr>
<tr class="separator:a3ba67e1154ce022506b4d3ad0760bd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55c97f2a3b9bda303b08e8bcd5078b0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#af55c97f2a3b9bda303b08e8bcd5078b0">stateDerivative</a> (const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:af55c97f2a3b9bda303b08e8bcd5078b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internal continuous state.  <a href="#af55c97f2a3b9bda303b08e8bcd5078b0">More...</a><br /></td></tr>
<tr class="separator:af55c97f2a3b9bda303b08e8bcd5078b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad949064b4945c835e2e290d2e7121de1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#ad949064b4945c835e2e290d2e7121de1">parameterAtIndexIsTunable</a> (unsigned index)</td></tr>
<tr class="memdesc:ad949064b4945c835e2e290d2e7121de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify if the parameter at the specified index is tunable.  <a href="#ad949064b4945c835e2e290d2e7121de1">More...</a><br /></td></tr>
<tr class="separator:ad949064b4945c835e2e290d2e7121de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fce73fe89cc230e4c223f60dccbde2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a21fce73fe89cc230e4c223f60dccbde2">parseParameters</a> (<a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:a21fce73fe89cc230e4c223f60dccbde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the parameters stored into the <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">core::BlockInformation</a> object.  <a href="#a21fce73fe89cc230e4c223f60dccbde2">More...</a><br /></td></tr>
<tr class="separator:a21fce73fe89cc230e4c223f60dccbde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a728d883d6f87fde45b481f783f7379"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a2a728d883d6f87fde45b481f783f7379">getParameters</a> (<a class="el" href="classblockfactory_1_1core_1_1_parameters.html">blockfactory::core::Parameters</a> &amp;params) const </td></tr>
<tr class="memdesc:a2a728d883d6f87fde45b481f783f7379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather all the stored parameters.  <a href="#a2a728d883d6f87fde45b481f783f7379">More...</a><br /></td></tr>
<tr class="separator:a2a728d883d6f87fde45b481f783f7379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb40d2bd1d43f6e938452b198b6b5fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#acfb40d2bd1d43f6e938452b198b6b5fd">configureSizeAndPorts</a> (<a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:acfb40d2bd1d43f6e938452b198b6b5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the input and output ports.  <a href="#acfb40d2bd1d43f6e938452b198b6b5fd">More...</a><br /></td></tr>
<tr class="separator:acfb40d2bd1d43f6e938452b198b6b5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f5743e10b9c8cb4c4cc4ce86d650b2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#ac2f5743e10b9c8cb4c4cc4ce86d650b2">initialize</a> (<a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:ac2f5743e10b9c8cb4c4cc4ce86d650b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the block.  <a href="#ac2f5743e10b9c8cb4c4cc4ce86d650b2">More...</a><br /></td></tr>
<tr class="separator:ac2f5743e10b9c8cb4c4cc4ce86d650b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bef9368694c2b596e0ff007dc940e68"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a8bef9368694c2b596e0ff007dc940e68">initializeInitialConditions</a> (const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:a8bef9368694c2b596e0ff007dc940e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize block initial conditions.  <a href="#a8bef9368694c2b596e0ff007dc940e68">More...</a><br /></td></tr>
<tr class="separator:a8bef9368694c2b596e0ff007dc940e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d662aeca0016ad63c8a1c7750c6c713"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a2d662aeca0016ad63c8a1c7750c6c713">terminate</a> (const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)</td></tr>
<tr class="memdesc:a2d662aeca0016ad63c8a1c7750c6c713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup block resources.  <a href="#a2d662aeca0016ad63c8a1c7750c6c713">More...</a><br /></td></tr>
<tr class="separator:a2d662aeca0016ad63c8a1c7750c6c713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d686e8917840e9d90e3cae2fc7cf64"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a86d686e8917840e9d90e3cae2fc7cf64">output</a> (const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *blockInfo)=0</td></tr>
<tr class="memdesc:a86d686e8917840e9d90e3cae2fc7cf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the output of the block.  <a href="#a86d686e8917840e9d90e3cae2fc7cf64">More...</a><br /></td></tr>
<tr class="separator:a86d686e8917840e9d90e3cae2fc7cf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a466743921038b521a8ac085c7739bd72"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a466743921038b521a8ac085c7739bd72">NumberOfParameters</a> = 2</td></tr>
<tr class="memdesc:a466743921038b521a8ac085c7739bd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of parameters of <a class="el" href="classblockfactory_1_1core_1_1_block.html" title="Basic abstract class for wrapping generic algorithms. ">core::Block</a>.  <a href="#a466743921038b521a8ac085c7739bd72">More...</a><br /></td></tr>
<tr class="separator:a466743921038b521a8ac085c7739bd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a063836c2459d24401dd351b2abdbb595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblockfactory_1_1core_1_1_parameters.html">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblockfactory_1_1core_1_1_block.html#a063836c2459d24401dd351b2abdbb595">m_parameters</a></td></tr>
<tr class="memdesc:a063836c2459d24401dd351b2abdbb595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for block parameters. You can get this member using <a class="el" href="classblockfactory_1_1core_1_1_block.html#a2a728d883d6f87fde45b481f783f7379" title="Gather all the stored parameters. ">Block::getParameters</a>.  <a href="#a063836c2459d24401dd351b2abdbb595">More...</a><br /></td></tr>
<tr class="separator:a063836c2459d24401dd351b2abdbb595"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9b4d459fe39915cbe85d738bb767d458"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual blockfactory::core::Block::~Block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7870c7ff32f7f8c4f475baa18b7675e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; blockfactory::core::Block::additionalBlockOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector of additional block options. </p>
<p>Implement this method if you want to store in the <a class="el" href="classblockfactory_1_1core_1_1_block.html" title="Basic abstract class for wrapping generic algorithms. ">Block</a> additional options that can be parsed later from <a class="el" href="classblockfactory_1_1core_1_1_block_information.html#ab433996c89aaaf07f2d932206399d57e" title="Convert a block option from its string identifier to a specific implementation. ">BlockInformation::optionFromKey</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector containing a list of options. </dd></dl>

</div>
</div>
<a class="anchor" id="acfb40d2bd1d43f6e938452b198b6b5fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::configureSizeAndPorts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the input and output ports. </p>
<p>Implement this method to set information about number and size of input and output ports. The terminology <code>port</code> comes as Simulink inheritage, and it marks the connection of a signal (which resides in some buffer in the program memory) to the block input or output.</p>
<p>These information will be used later (e.g. in the <a class="el" href="classblockfactory_1_1core_1_1_block.html#ac2f5743e10b9c8cb4c4cc4ce86d650b2" title="Initialize the block. ">core::Block::initialize</a> and <a class="el" href="classblockfactory_1_1core_1_1_block.html#a86d686e8917840e9d90e3cae2fc7cf64" title="Compute the output of the block. ">core::Block::output</a>) for preallocating resources and accessing data knowing its size in advance.</p>
<dl class="section note"><dt>Note</dt><dd>If the size is not known (core::Signal::DynamicSize) during this configuring phase, at latest it should be set in the <a class="el" href="classblockfactory_1_1core_1_1_block.html#ac2f5743e10b9c8cb4c4cc4ce86d650b2" title="Initialize the block. ">core::Block::initialize</a> method. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not allocate any data in this stage! Object are destroyed afterwards and created again before the <a class="el" href="classblockfactory_1_1core_1_1_block.html#ac2f5743e10b9c8cb4c4cc4ce86d650b2" title="Initialize the block. ">core::Block::initialize</a> step. All allocated memory and stored values will be deleted. Only information stored in <code>blockInfo</code> will persist.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the block was configured successfully, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>core::BlockInformation::setIOPortsData </dd></dl>

</div>
</div>
<a class="anchor" id="a2a728d883d6f87fde45b481f783f7379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blockfactory::core::Block::getParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblockfactory_1_1core_1_1_parameters.html">blockfactory::core::Parameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather all the stored parameters. </p>
<p>After the parameters have been successfully stored and parsed using the core::Block::parseParameter, you can gather them using this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>A <a class="el" href="classblockfactory_1_1core_1_1_parameters.html" title="Class for storing block&#39;s parameters. ">core::Parameters</a> object containing block parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True for success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4b0465b444ee55679c7602fe90b84fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string blockfactory::core::Block::getUniqueName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the unique name of the block instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique name of the block instance if it was set, an empty string otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2f5743e10b9c8cb4c4cc4ce86d650b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the block. </p>
<p>Implement this method to initialize and allocate the resources the algorithm needs during its execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bef9368694c2b596e0ff007dc940e68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::initializeInitialConditions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize block initial conditions. </p>
<p>Implement this method to specify block initial conditions. Its execution will happen after block::Block::initialize and before the first call of <a class="el" href="classblockfactory_1_1core_1_1_block.html#a86d686e8917840e9d90e3cae2fc7cf64" title="Compute the output of the block. ">core::Block::output</a>. The default is an empty implementation.</p>
<dl class="section note"><dt>Note</dt><dd>This function is also called on a reset event. In Simulink, an example is when the block resides in an enabled subsystem.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a917d00d0c7fb9d28ab4b37657add7639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned blockfactory::core::Block::numberOfContinuousStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of continuous states of the block. </p>
<p>The base implementation returns 0, i.e. no continuous states.</p>
<dl class="section note"><dt>Note</dt><dd>If you return a number &gt; 0, you should implement the <a class="el" href="classblockfactory_1_1core_1_1_block.html#af55c97f2a3b9bda303b08e8bcd5078b0" title="Update the internal continuous state. ">Block::stateDerivative</a> function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of continuous states. </dd></dl>

</div>
</div>
<a class="anchor" id="a90061447ea56e809f3e882b2c0d4a7c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned blockfactory::core::Block::numberOfDiscreteStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of discrete states of the block. </p>
<p>The base implementation returns 0, i.e. no discrete states.</p>
<dl class="section note"><dt>Note</dt><dd>If you return a number &gt; 0, you should implement the <a class="el" href="classblockfactory_1_1core_1_1_block.html#a3ba67e1154ce022506b4d3ad0760bd52" title="Update the internal discrete state. ">Block::updateDiscreteState</a> function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of discrete states. </dd></dl>

</div>
</div>
<a class="anchor" id="a85176801eb52d1a350af994438f5b973"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned blockfactory::core::Block::numberOfParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of configuration parameters needed by this block. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of parameters.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classblockfactory_1_1core_1_1_block.html#a466743921038b521a8ac085c7739bd72" title="Number of parameters of core::Block. ">Block::NumberOfParameters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a86d686e8917840e9d90e3cae2fc7cf64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::output </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the output of the block. </p>
<p>This method is called at every iteration of the model. Implement here a single step of the algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad949064b4945c835e2e290d2e7121de1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::parameterAtIndexIsTunable </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify if the parameter at the specified index is tunable. </p>
<p>Tunable means that it can be changed during the simulation. Usually parameters are defined before the beginning of the simulation and they stay constant for all its duration.</p>
<dl class="section note"><dt>Note</dt><dd>For the time being tunable parameters are not used in this toolbox.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the parameter is tunable, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a21fce73fe89cc230e4c223f60dccbde2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::parseParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the parameters stored into the <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">core::BlockInformation</a> object. </p>
<p>Implement this method to create the metadata of the parameters your block needs (using <a class="el" href="classblockfactory_1_1core_1_1_parameter_metadata.html" title="Class for storing parameter metadata. ">core::ParameterMetadata</a>), store them into the blockInfo object with <a class="el" href="classblockfactory_1_1core_1_1_block_information.html#a9365c63daeda48771d98843d795e8345" title="Add a parameter metadata. ">core::BlockInformation::addParameterMetadata</a>, and parse them using <a class="el" href="classblockfactory_1_1core_1_1_block_information.html#ab5ef013c3fbfec82f73a9806b2e2d851" title="Parse the core::Block parameters. ">core::BlockInformation::parseParameters</a>.</p>
<p>An example of the implementation is the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyBlock::parseParameters(BlockInformation* blockInfo)</div><div class="line">{</div><div class="line">    ParameterMetadata fooMetadata(PARAM_STRING, PARAM_IDX_FRAME, 1, 1, <span class="stringliteral">&quot;foo&quot;</span>);</div><div class="line">    <span class="keywordtype">bool</span> ok = blockInfo-&gt;addParameterMetadata(fooMetadata);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!ok) {</div><div class="line">        <a class="code" href="_log_8h.html#a9e1cf689145bbec09dd0414fc6da9f63">bfError</a> &lt;&lt; <span class="stringliteral">&quot;Failed to store parameter metadata.&quot;</span>;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> blockInfo-&gt;parseParameters(<a class="code" href="classblockfactory_1_1core_1_1_block.html#a063836c2459d24401dd351b2abdbb595">m_parameters</a>);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classblockfactory_1_1core_1_1_block_information.html#a9365c63daeda48771d98843d795e8345" title="Add a parameter metadata. ">core::BlockInformation::addParameterMetadata</a>, <a class="el" href="classblockfactory_1_1core_1_1_block_information.html#ab5ef013c3fbfec82f73a9806b2e2d851" title="Parse the core::Block parameters. ">core::BlockInformation::parseParameters</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af55c97f2a3b9bda303b08e8bcd5078b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::stateDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internal continuous state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d662aeca0016ad63c8a1c7750c6c713"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::terminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleanup block resources. </p>
<p>This method is called during the termination of the execution. Implement this method to deallocate all the memory requested during the previous steps or to perform other terminating operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ba67e1154ce022506b4d3ad0760bd52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blockfactory::core::Block::updateDiscreteState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblockfactory_1_1core_1_1_block_information.html">BlockInformation</a> *&#160;</td>
          <td class="paramname"><em>blockInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internal discrete state. </p>
<p>i.e. <code>x[i+1] = f(x[i])</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockInfo</td><td>The pointer to a <a class="el" href="classblockfactory_1_1core_1_1_block_information.html" title="Abstract class for storing generic core::Block properties. ">BlockInformation</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success, false otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a063836c2459d24401dd351b2abdbb595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblockfactory_1_1core_1_1_parameters.html">Parameters</a> blockfactory::core::Block::m_parameters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container for block parameters. You can get this member using <a class="el" href="classblockfactory_1_1core_1_1_block.html#a2a728d883d6f87fde45b481f783f7379" title="Gather all the stored parameters. ">Block::getParameters</a>. </p>

</div>
</div>
<a class="anchor" id="a466743921038b521a8ac085c7739bd72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned blockfactory::core::Block::NumberOfParameters = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of parameters of <a class="el" href="classblockfactory_1_1core_1_1_block.html" title="Basic abstract class for wrapping generic algorithms. ">core::Block</a>. </p>
<p>Static variable matching <a class="el" href="classblockfactory_1_1core_1_1_block.html#a85176801eb52d1a350af994438f5b973" title="Returns the number of configuration parameters needed by this block. ">Block::numberOfParameters</a>. It might be useful to define parametric constants for parameter indices in child blocks. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/robotology/blockfactory/sources/Core/include/BlockFactory/Core/<a class="el" href="_block_8h_source.html">Block.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceblockfactory.html">blockfactory</a></li><li class="navelem"><a class="el" href="namespaceblockfactory_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classblockfactory_1_1core_1_1_block.html">Block</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
